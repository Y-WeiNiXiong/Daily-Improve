#                                 JVM内存划分

## 程序计数器

* 是一块较小的内存空间，可以将其看做是当前线程所执行的字节码行号指示器。字节码解释器工作时便是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
* 该区域是各个线程度独有的空间，线程之间计数器互不影响，独立存储，是线程隔离的
* 该区域是唯一一个不会发生OOM的区域

## Java虚拟机栈

* 我们平时所说的栈就是指这个区域。和程序计数器一样，该区域也是各个线程私有的。生命周期与线程相
* 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口灯信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程
* 局部变量表存放了编译期可知的各种基本数据类型、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）
* 当访问的栈深度超过虚拟机允许的深度，会抛出StackOverflowError；当扩展时如果无法获取足够的空间，会抛出OOM异常
* 通过参数-Xss调整该区域大小

## 本地方法栈

* 本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法提供服务，而本地方法栈则为虚拟机使用的Native方法服务。
* 和虚拟机栈一样，同样会抛出StackOverflowError和OOM异常

## Java堆

* java虚拟机所管理的内存中最大的一块。是各个线程所共享的区域，在虚拟机启动时创建。
* 几乎所有的对象和数组都在该区域分配
* 由于现在的虚拟机采用分代收集算法，所以从这个角度来看，该区域又可以分成新生代、老年代。新生代又可以细分成Eden区和两个Survivor区，大小8:1:1
* 当该区域空间不足时会抛出OOM异常
* 通过参数-Xmx、-Xms调整大小

## 方法区

* 和堆一样，是被各个线程共享的区域
* 用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据
* 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用
* 当该区域空间不足时会抛出OOM异常
* 通过参数-XX：MaxPermSize调整大小

## 堆外内存

* 不是虚拟机运行时数据区的一部分
* 是内存就受整体内存大小的限制，默认大小和堆的大小一样
* 当调整堆、栈空间大小时，容易忽略该区域的大小，导致所有内存加起来超过总内存大小，从而抛出OOM异常
* 通过参数-XX：MaxDirectMemorySize调整大小